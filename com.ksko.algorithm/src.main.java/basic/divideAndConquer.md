# 분할정복

## 개념
거의 같은 크기로 둘 이상의 부분 문제로 나누어 계산하고, 전체 문제의 답을 도출한다.

## 구성 요소 
	◦ 분할(divide)
	◦ 병합(merge)
	◦ 분할하지 않고 곧장 풀 수 있는 매우 작은 문제(base case)

## 장점  
같은 작업을 빠르게 처리할 수 있다.  
	◦ 예를 들어서, 1+2+3+...+n의 문제?
		‣ 분할
			• (1+2+3+...+n/2) + ((n/2+1)+(n/2+2)+...+n)
			• 이때 뒤의 부분은 (n/2+1)+(n/2+2)+...+(n/2+n/2)로 표기할 수 있다.
			• =n/2*n/2 + (1+2+3+...+n/2)
			• 이때 뒤의 부분은 이전에 처음 분할할 때 앞 부분과 같으므로,
			• f(x) = 2*f(x)+n^2/4이다.


<pre><code>

int fastSun(int n) {
	if(n==1) return 1; //base case
	if(n%2==1) return fastSum(n-1)+n; //base case
	return 2*fastSum(n/2) + (n/2)*(n/2); //분할 + 병합
}

</code></pre>

• 포인트 : 행위가 다 같다(두 수를 더한다), 기본 행위와 마지막 행위가 같다(base case와 최종 행위), 나눌 수 있다.
• 시간 복잡도 : 재귀호출로 계산하면 n번만큼 호출, 분할정복으로 하면 절반씩 나눠서 계산하므로 O(logN)


## 퀵정렬
• 피봇을 정해서 피봇보다 작으면 왼쪽, 크면 오른쪽으로 보내는 과정이다.
• 피봇에 따라서 비효율적일 수 있지만 부분별로 정렬된 상태가 되기 때문에 병합작업이 필요없다.
• 시간복잡도 : O(n^2)~O(nlogN)
* 퀵 정렬을 구현하는 데는 분할 방법을 기준으로 두 가지로 나눌 수 있다.  
  
### Hoare partition
1. 시작 인덱스를 피봇으로 설정하고
2. 시작인덱스가 끝 인덱스에 닿을 때까지 돌면서
3. 시작인덱스와 피봇, 끝 인덱스와 피봇과 비교하며 각각 작은값, 큰값이 나올때까지 이동한다.
4. 각각 멈춘 지점에서 시작인덱스가 끝인덱스보다 여전히 작으면 스와핑한다.**베이스 케이스**
5. 교차하는 지점이 오면 피봇보다 작은 값을 가리키고 있는 인덱스와 피봇을 ㄱ환한다.
6. 그 피봇을 기준으로 **분할**한다.
  
**슈도 코드 -**
<pre><code>
hoare(A[], l, r) {
	p = A[l];
	i = l, j=r;
	while(i<=j) {
		//구성요소 - 분할
		while(A[i] > p) i++;
		while(A[i] <= p) j--;
		if(i<j) swap(A[i],A[j]); //구성요소 - base case
	}
	
	swap(A[l], A[j]);
	return j;
}
</code></pre>
  
**피봇 선택 기준-  **
보통 피봇은 처음, 중간, 끝 인덱스를 선택한다. 근데 값이 중간 값인 것이 정렬에 유리하므로 처음, 중간, 끝 인덱스 중 값이 중간인 것을 선택한다.
  
### Lomuto partition
  
슈도코드 -
  
<pre><code>
lomto(A[], l,r) {
	p = A[r];
	i = l-1;
	for(int j = i ~ r-1)
		if(A[j] <= p)
			i++; swap(A[i], A[j]);
			
	swap(A[i+1], A[r]);
	return i+1
}
</code></pre>
  
1. j를 처음부터 피봇 앞 까지 증가시키면서  
2. 피봇보다 작은 값을 발견하면 i를 증가시키고  
3. i값과 j값을 스와핑한다.(피봇보다 큰 값을 발견할때까지 i와 j는 값이 같으므로 스와핑해도 변화가 일어나지 않는다.)  
4. 피봇보다 큰 값을 발견하면 아무것도 수행하지 않고 다음 작은 값을 발견할때까지 혼자 올라간다.
5. 작은 값을 발견하면 이하 2번
6. 끝까지 오고 나면, i는 큰 값을 가리키고 있다. 이 값과 피봇값을 바꿔준다. i가 다음 정렬의 피봇이 된다.
  
  
## 쿼드트리  

